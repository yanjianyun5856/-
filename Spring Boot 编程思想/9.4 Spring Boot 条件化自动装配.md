## Spring Boot 条件化自动装配

### Class 条件注解

Class 条件注解是一对语义相反的 @ConditionalOnClass 和 @ConditionalOnMissingClass ,分别表达 **当指定类存在时**  和 当**指定类缺失 的** 语义。

```java
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnClassCondition.class)
public @interface ConditionalOnClass {

   Class<?>[] value() default {};

   String[] name() default {};

}
```



```java
@Target({ ElementType.TYPE, ElementType.METHOD })
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Conditional(OnClassCondition.class)
public @interface ConditionalOnMissingClass {

   String[] value() default {};

}
```



@ConditionalOnClass 和 @ConditionalOnMissingClass 均使用 @Conditional(OnClassCondition.class) 实现：

```java
@Order(Ordered.HIGHEST_PRECEDENCE)
class OnClassCondition extends FilteringSpringBootCondition {

	@Override
	public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
		ClassLoader classLoader = context.getClassLoader();
		ConditionMessage matchMessage = ConditionMessage.empty();
		List<String> onClasses = getCandidates(metadata, ConditionalOnClass.class);
		if (onClasses != null) {
			List<String> missing = filter(onClasses, ClassNameFilter.MISSING, classLoader);
			if (!missing.isEmpty()) {
				return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)
						.didNotFind("required class", "required classes").items(Style.QUOTE, missing));
			}
			matchMessage = matchMessage.andCondition(ConditionalOnClass.class)
					.found("required class", "required classes")
					.items(Style.QUOTE, filter(onClasses, ClassNameFilter.PRESENT, classLoader));
		}
		List<String> onMissingClasses = getCandidates(metadata, ConditionalOnMissingClass.class);
		if (onMissingClasses != null) {
			List<String> present = filter(onMissingClasses, ClassNameFilter.PRESENT, classLoader);
			if (!present.isEmpty()) {
				return ConditionOutcome.noMatch(
                    	ConditionMessage.forCondition(ConditionalOnMissingClass.class)
						.found("unwanted class", "unwanted classes").items(Style.QUOTE, present));
			}
			matchMessage = matchMessage.andCondition(ConditionalOnMissingClass.class)
					.didNotFind("unwanted class", "unwanted classes")
					.items(Style.QUOTE, filter(onMissingClasses, ClassNameFilter.MISSING, classLoader));
		}
		return ConditionOutcome.match(matchMessage);
	}    
}
```



#### 整合 Class 条件注解 - 重构 formatter-spring-boot-starter

在 formatter-spring-boot-starter 的实现中 ，FormatterAutoConfiguration 声明了一个名为 defaultFormatter 的 DefaultFormatter Bean，该bean 运用 String#valueOf(Object) 方法实现对象的格式化。 然而该实现已不再适合复杂对象格式化的需求，FormatterAutoConfiguration 需要增加一个输出 JSON 格式的 Formatter 实现 - JsonFormatter ,并需要依赖第三方库，Jackson 作为 JSON 序列化的工具。故实现如下：

#####  1.增加Jackson 依赖到 pom.xml

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <optional>true</optional><!-- 不传递依赖  -->
</dependency>
```



##### 2.新增 JSON Formatter 实现 - JsonFormatter

```java
public class JsonFormatter implements Formatter {

    private final ObjectMapper objectMapper;

    public JsonFormatter() {
        this.objectMapper = new ObjectMapper();
    }

    @Override
    public String format(Object object) {
        try {
            return objectMapper.writeValueAsString(object);
        } catch (JsonProcessingException e) {
            //解析失败返回非法参数异常
            throw new IllegalArgumentException(e);
        }
    }
}
```

##### 3.新增 JsonFormatter Bean 声明到 FormatterAutoConfiguration

```java
@Configuration
public class FormatterAutoConfiguration {

    @Bean
    public Formatter defaultFormatter() {
        return new DefaultFormatter();
    }

    @Bean
    public Formatter jsonFormatter(){
        return new JsonFormatter();
    }
}
```

明显地，在 同一个 Spring 应用上下文中出现了两个 Formatter Bean，为了避免 Formatter Bean 唯一性冲突，故有以下步骤。

##### 4.Formatter Bean 整合 Class 条件注解

两个 Formatter Bean 可使用互斥的Class 条件注解 @ConditionalOnMissingClass 和 @ConditionalOnClass

```java
@Configuration
public class FormatterAutoConfiguration {

    @Bean
    @ConditionalOnMissingClass(value = "com.fasterxml.jackson.databind.ObjectMapper")
    public Formatter defaultFormatter() {
        return new DefaultFormatter();
    }

    @Bean
    @ConditionalOnClass(name = "com.fasterxml.jackson.databind.ObjectMapper")
    public Formatter jsonFormatter(){
        return new JsonFormatter();
    }
}
```

##### 5.微调 FormatterBootStrap

```java
@EnableAutoConfiguration
public class FormatterBootstrap {
    public static void main(String[] args) {
        ConfigurableApplicationContext context = new SpringApplicationBuilder(FormatterBootstrap.class)
                .web(WebApplicationType.NONE)
                .run(args);

        //待格式化对象
        Map<String,Object> data = new HashMap<>();
        data.put("name", "yjy");
        //获取 Formatter， 来自 FormatterAutoConfiguration
        Formatter formatter = context.getBean(Formatter.class);
        System.out.printf("%s.format(date:%s) \n",
                          formatter.getClass().getSimpleName(),formatter.format(data));

        context.close();
    }
}
```

输出

```
DefaultFormatter.format(date:{name=yjy}) 
```

从运行日志分析，DefaultFormatter 仍旧选为 格式化组件Bean，说明 FormatterBootstrap 所在的 auto-configuration-sample 工厂并没有依赖 Jackson 的第三方库。

将 `com.fasterxml.jackson.core:jackson-databind` 加入 auto-configuration-sample 的 pom.xml

```
 		<dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
```



重启 FormatterBootstrap ，日志输出：

```
JsonFormatter.format(date:{"name":"yjy"}) 
```

由于工厂引入  `com.fasterxml.jackson.core:jackson-databind`  的缘故 JacksonAutoConfiguration 也被自动装配，他也是基于 @ConditionalOnClass 的条件化自动装配实现的：

```java
@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(ObjectMapper.class)
public class JacksonAutoConfiguration {
    
    
	@Configuration(proxyBeanMethods = false)
	@ConditionalOnClass(Jackson2ObjectMapperBuilder.class)
	static class JacksonObjectMapperConfiguration {

		@Bean
		@Primary
		@ConditionalOnMissingBean
		ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) {
			return builder.createXmlMapper(false).build();
		}

	}
}
```





