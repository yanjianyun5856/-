依照@Enable 模块驱动设计模式，@EnableAutoConfiguration 必然 ”@Import“ ImportSelector 或 ImportBeanDefinitionRegistrar 的实现类。于是参考其注解定义：

```java
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@AutoConfigurationPackage
@Import({EnableAutoConfigurationImportSelector.class})
public @interface EnableAutoConfiguration {
    String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";

    Class<?>[] exclude() default {};

    String[] excludeName() default {};
}
```

EnableAutoConfigurationImportSelector

```java
public class EnableAutoConfigurationImportSelector extends AutoConfigurationImportSelector {
   
}

public class AutoConfigurationImportSelector implements DeferredImportSelector, 
		BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	
	
}

public interface DeferredImportSelector extends ImportSelector {

}

```

其中 AutoConfigurationImportSelector就是 @EnableAutoConfiguration 所 “Import” 的 DeferredImportSelector 实现类，由于 DeferredImportSelector 作为 ImportSelector  的子接口，所以组件自动装配逻辑均在 selectImport(AnnotationMetadata) 方法中实现：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, 
		BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {

	@Override
	public String[] selectImports(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return NO_IMPORTS;
		}
		AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);
		return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());
	}
            
	protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) {
		if (!isEnabled(annotationMetadata)) {
			return EMPTY_ENTRY;
		}
        //获取标注类的元信息
		AnnotationAttributes attributes = getAttributes(annotationMetadata);
        //读取候选装配组件
		List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);
        //去重
		configurations = removeDuplicates(configurations);
        // 获取一个自动装配 Class 的排除名单
		Set<String> exclusions = getExclusions(annotationMetadata, attributes);
        // 检查排除类名集合是否合法
		checkExcludedClasses(configurations, exclusions);
        // 排除集合 exclusions 从候选自动装配 class名单 configurations 中移除
		configurations.removeAll(exclusions);
        // filter 过滤自动装配组件
		configurations = getConfigurationClassFilter().filter(configurations);
        //触发自动装配的导入事件
		fireAutoConfigurationImportEvents(configurations, exclusions);
		return new AutoConfigurationEntry(configurations, exclusions);
	}

}
```



####  @EnableAutoConfiguration 读取候选装配组件

`getCandidateConfigurations(AnnotationMetadata, AnnotationAttributes)` 方法

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, 
		BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {

	protected List<String> getCandidateConfigurations(AnnotationMetadata metadata, 
                                                      AnnotationAttributes attributes) {
		List<String> configurations = SpringFactoriesLoader.
            loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());
	
		return configurations;
	}            
     
	protected Class<?> getSpringFactoriesLoaderFactoryClass() {
		return EnableAutoConfiguration.class;
	}       
}            
```

该方法实际执行的是 SpringFactoriesLoader#loadFactoryNames(Class, ClassLoader)

```java
public final class SpringFactoriesLoader {

	public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";

	public static List<String> loadFactoryNames(Class<?> factoryType, @Nullable ClassLoader classLoader) {
		ClassLoader classLoaderToUse = classLoader;
		if (classLoaderToUse == null) {
			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
		}
		String factoryTypeName = factoryType.getName();
		return loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());
	}
    
    
	private static Map<String, List<String>> loadSpringFactories(ClassLoader classLoader) {
		Map<String, List<String>> result = cache.get(classLoader);
		if (result != null) {
			return result;
		}

		result = new HashMap<>();
		try {
			Enumeration<URL> urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);
			while (urls.hasMoreElements()) {
				URL url = urls.nextElement();
				UrlResource resource = new UrlResource(url);
				Properties properties = PropertiesLoaderUtils.loadProperties(resource);
				for (Map.Entry<?, ?> entry : properties.entrySet()) {
					String factoryTypeName = ((String) entry.getKey()).trim();
					String[] factoryImplementationNames =
							StringUtils.commaDelimitedListToStringArray((String) entry.getValue());
					for (String factoryImplementationName : factoryImplementationNames) {
						result.computeIfAbsent(factoryTypeName, key -> new ArrayList<>())
								.add(factoryImplementationName.trim());
					}
				}
			}

			// Replace all lists with unmodifiable lists containing unique elements
			result.replaceAll((factoryType, implementations) -> implementations.stream().distinct()
					.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));
			cache.put(classLoader, result);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException("Unable to load factories from location ...]", ex);
		}
		return result;
	}
}
```



SpringFactoriesLoader 是 Spring Framework 工厂机制的加载器，loadFactoryNames(Class, ClassLoader)方法加载原理如下：

1. 搜索指定 ClassLoader 下所有的 META-INF/spring.factories 资源内容。
2. 将一个或多个  META-INF/spring.factories 资源内容作为 Properties 文件读取，合并为一个Map， key 为接口的全类名，Value 是实现类全类名列表，将 Map 作为loadSpringFactories 方法的返回值。
3. 再从上一步返回的 Map 中查找并返回指定类名所映射的实现类全类名列表。



由于 @EnableAutoConfiguration 配置可能存在自动装配组件类名重复定义的情况，当`getCandidateConfigurations(AnnotationMetadata, AnnotationAttributes)` 方法 获取所有的候选类集合名后，立即执行 removeDuplicates 方法，利用 set 不可重复性达到去重的目的：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, 
		BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	protected final <T> List<T> removeDuplicates(List<T> list) {
		return new ArrayList<>(new LinkedHashSet<>(list));
	}
}
```



#### @EnableAutoConfiguration 排除自动装配组件

当 getExclusions(AnnotationMetadata,AnnotationAttributes) 方法执行后，程序将获得一个自动装配 Class 的排除名单：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, 
		BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	
	protected Set<String> getExclusions(AnnotationMetadata metadata, AnnotationAttributes attributes) {
		Set<String> excluded = new LinkedHashSet<>();
		excluded.addAll(asList(attributes, "exclude"));
		excluded.addAll(Arrays.asList(attributes.getStringArray("excludeName")));
		excluded.addAll(getExcludeAutoConfigurationsProperty());
		return excluded;
	}
    
	protected List<String> getExcludeAutoConfigurationsProperty() {
		Environment environment = getEnvironment();
		if (environment == null) {
			return Collections.emptyList();
		}
		if (environment instanceof ConfigurableEnvironment) {
			Binder binder = Binder.get(environment);
			return binder.bind(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class).map(Arrays::asList)
					.orElse(Collections.emptyList());
		}
		String[] excludes = environment.getProperty(PROPERTY_NAME_AUTOCONFIGURE_EXCLUDE, String[].class);
		return (excludes != null) ? Arrays.asList(excludes) : Collections.emptyList();
	}


	
}
```

该方法的实现相对简单，将标注 @EnableAutoConfiguration 配置类的注解属性 exclude 和 excludeName 以及将 spring.autoconfiguration.exclude 配置值累加至排除集合 excluded 。随后检查排除类名集合是否合法：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, 
		BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	
	private void checkExcludedClasses(List<String> configurations, Set<String> exclusions) {
		List<String> invalidExcludes = new ArrayList<>(exclusions.size());
		for (String exclusion : exclusions) {
			if (ClassUtils.isPresent(exclusion, getClass().getClassLoader()) && 
                	!configurations.contains(exclusion)) {
				invalidExcludes.add(exclusion);
			}
		}
		if (!invalidExcludes.isEmpty()) {
			handleInvalidExcludes(invalidExcludes);
		}
	}
}
```

当排除类存在于当前 ClassLoader 且不在自动装配候选类名单中时：handleInvalidExcludes 方法被执行，触发排除类非法异常。

接着该排除集合 exclusions 从候选自动装配 class名单 configurations 中移除：configurations.removeAll(exclusions);



####  @EnableAutoConfiguration 过滤自动装配组件

移除排名类名单后的 configurations 配合 AutoConfigurationMetadata 对象执行过滤操作：

```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, 
		BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {
	
	private static class ConfigurationClassFilter {

		List<String> filter(List<String> configurations) {
			long startTime = System.nanoTime();
			String[] candidates = StringUtils.toStringArray(configurations);
			boolean skipped = false;
			for (AutoConfigurationImportFilter filter : this.filters) {
				boolean[] match = filter.match(candidates, this.autoConfigurationMetadata);
				for (int i = 0; i < match.length; i++) {
					if (!match[i]) {
						candidates[i] = null;
						skipped = true;
					}
				}
			}
			if (!skipped) {
				return configurations;
			}
			List<String> result = new ArrayList<>(candidates.length);
			for (String candidate : candidates) {
				if (candidate != null) {
					result.add(candidate);
				}
			}
			if (logger.isTraceEnabled()) {
				int numberFiltered = configurations.size() - result.size();
				logger.trace("Filtered ...auto configuration class in ... ms");
			}
			return result;
		}

    }

	private ConfigurationClassFilter getConfigurationClassFilter() {
		if (this.configurationClassFilter == null) {
			List<AutoConfigurationImportFilter> filters = getAutoConfigurationImportFilters();
			for (AutoConfigurationImportFilter filter : filters) {
				invokeAwareMethods(filter);
			}
			this.configurationClassFilter = new ConfigurationClassFilter(this.beanClassLoader, filters);
		}
		return this.configurationClassFilter;
	}
            
    protected List<AutoConfigurationImportFilter> getAutoConfigurationImportFilters() {
		return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, 
                                                   this.beanClassLoader);
	}

}
```

其中 AutoConfigurationImportFilter 对象集合同样被 SpringFactoriesLoader 加载，故查找 AutoConfigurationImportFilter 在所有 META-INF/spring.factories 资源中的配置。Spring Boot 框架默认仅有一处声明，即在 org.springframework.boot:spring-boot-autoconfiguration 中：

```
# Auto Configuration Import Filters
org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\
org.springframework.boot.autoconfigure.condition.OnBeanCondition,\
org.springframework.boot.autoconfigure.condition.OnClassCondition,\
org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition

```

不过此处的 SpringFactoriesLoader.loadFactories(Class, ClassLoader) 方法与之前讨论的 loadFactoryNames(Class, ClassLoader) 方法存在细微差别，由于前者调用了后者，所有他们在类名单加载部分的逻辑是相同的：

```java
public final class SpringFactoriesLoader {
	
	public static <T> List<T> loadFactories(Class<T> factoryType, @Nullable ClassLoader classLoader) {
		Assert.notNull(factoryType, "'factoryType' must not be null");
		ClassLoader classLoaderToUse = classLoader;
		if (classLoaderToUse == null) {
			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();
		}
		List<String> factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse);
		if (logger.isTraceEnabled()) {
			logger.trace("Loaded [" + factoryType.getName() + "] names: " + factoryImplementationNames);
		}
		List<T> result = new ArrayList<>(factoryImplementationNames.size());
		for (String factoryImplementationName : factoryImplementationNames) {
			result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse));
		}
		AnnotationAwareOrderComparator.sort(result);
		return result;
	}

	private static <T> T instantiateFactory(String factoryImplementationName, 
                                            Class<T> factoryType, ClassLoader classLoader) {
		try {
			Class<?> factoryImplementationClass =
                ClassUtils.forName(factoryImplementationName, classLoader);
			if (!factoryType.isAssignableFrom(factoryImplementationClass)) {
				throw new IllegalArgumentException(
						"Class...is not assignable to factory type ");
			}
			return (T) ReflectionUtils.accessibleConstructor(factoryImplementationClass).newInstance();
		}
		catch (Throwable ex) {
			throw new IllegalArgumentException( "Unable to instantiate factory class for factory type", ex);
		}
	}
}
```

两者 区别在于，前者获取工厂名单 factoryNames 后将，他们逐一进行类加载，这些类必须是参数 factoryClass 的子类，并且被实例化且予以排序。换而言之，在 META-INF/spring.factories 资源中声明的 OnClassCondition 也是 AutoConfigurationImportFilter 的实现类。

方法参数依赖 AutoConfigurationMetadata 对象，分析AutoConfigurationMetadataLoader#LoadMetadata(ClassLoader) 方法：

```java
final class AutoConfigurationMetadataLoader {
	
    protected static final String PATH = "META-INF/spring-autoconfigure-metadata.properties";

	static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader) {
		return loadMetadata(classLoader, PATH);
	}

	static AutoConfigurationMetadata loadMetadata(ClassLoader classLoader, String path) {
		try {
			Enumeration<URL> urls = (classLoader != null) ? classLoader.getResources(path)
					: ClassLoader.getSystemResources(path);
			Properties properties = new Properties();
			while (urls.hasMoreElements()) {
				properties.putAll(PropertiesLoaderUtils.loadProperties(
                    new UrlResource(urls.nextElement())));
			}
			return loadMetadata(properties);
		}
		catch (IOException ex) {
			throw new IllegalArgumentException("Unable to load @ConditionalOnClass location。。。", ex);
		}
	}	
}
```

AutoConfigurationMetadataLoader 是 AutoConfigurationMetadata 的加载器。 AutoConfigurationMetadata 是 Spring Boot  1.5 开始引入的自动装配元信息接口，哲学系信息配置与 Properties 格式的资源 META-INF/spring-autoconfigure-metadata.properties 中，框架内部仅存在基于 Properties 文件格式的实现 PropertiesAutoConfigurationMetadata，被AutoConfigurationMetadataLoader 初始化。AutoConfigurationMetadata 接口支持多种数据类型的方法， OnClassCondition 作为 AutoConfigurationImportFilter 的实现类，他依赖于 AutoConfigurationMetadata#get 方法获取自动装配 Class 的 ConditionalOnClass 元信息：

```java
@Order(Ordered.HIGHEST_PRECEDENCE)
class OnClassCondition extends FilteringSpringBootCondition {
    
 	private static final class StandardOutcomesResolver implements OutcomesResolver {

		private ConditionOutcome[] getOutcomes(String[] autoConfigurationClasses, int start, int end,
				AutoConfigurationMetadata autoConfigurationMetadata) {
			ConditionOutcome[] outcomes = new ConditionOutcome[end - start];
			for (int i = start; i < end; i++) {
				String autoConfigurationClass = autoConfigurationClasses[i];
				if (autoConfigurationClass != null) {
					String candidates = autoConfigurationMetadata.get(
                        autoConfigurationClass, "ConditionalOnClass");
					if (candidates != null) {
						outcomes[i - start] = getOutcome(candidates);
					}
				}
			}
			return outcomes;
		}
        
    }
}
```

根据以上方法的逻辑，自动装配 Class 集合autoConfigurationClasses 迭代地调用 AutoConfigurationMetadata#get 方法获取他们的 

ConditionalOnClass 元信息。

以JMXAutoConfiguration为例，其 ConditionalOnClass  配置如下：

```properties
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration.ConditionalOnClass=org.springframework.jmx.export.MBeanExporter
```

> 以上为 META-INF/spring-autoconfigure-metadata.properties文件

当 `org.springframework.jmx.export.MBeanExporter` 作为方法返回值时，在直接使用 getOutcome(Set) 方法计算匹配结果：

```java
@Order(Ordered.HIGHEST_PRECEDENCE)
class OnClassCondition extends FilteringSpringBootCondition {
    
    
 	private static final class StandardOutcomesResolver implements OutcomesResolver {
   
		private ConditionOutcome getOutcome(String candidates) {
			try {
				if (!candidates.contains(",")) {
					return getOutcome(candidates, this.beanClassLoader);
				}
				for (String candidate : StringUtils.commaDelimitedListToStringArray(candidates)) {
					ConditionOutcome outcome = getOutcome(candidate, this.beanClassLoader);
					if (outcome != null) {
						return outcome;
					}
				}
			}
			catch (Exception ex) {
				// We'll get another chance later
			}
			return null;
		}
        
        private ConditionOutcome getOutcome(String className, ClassLoader classLoader) {
			if (ClassNameFilter.MISSING.matches(className, classLoader)) {
				return ConditionOutcome.noMatch(ConditionMessage.forCondition(ConditionalOnClass.class)
						.didNotFind("required class").items(Style.QUOTE, className));
			}
			return null;
		}
    }
}
```

最终，判断的标准由 ClassNameFilter.MISSING#matches方法决定：

```java
	protected enum ClassNameFilter {
    
    	MISSING {

			@Override
			public boolean matches(String className, ClassLoader classLoader) {
				return !isPresent(className, classLoader);
			}

		};
      
		static boolean isPresent(String className, ClassLoader classLoader) {
			if (classLoader == null) {
				classLoader = ClassUtils.getDefaultClassLoader();
			}
			try {
				resolve(className, classLoader);
				return true;
			}
			catch (Throwable ex) {
				return false;
			}
		}
  
    }
```



#### 总结

总而言之，AutoConfigurationImportSelector 读取自动装配的流程为：

1. 通过 SpringFactoriesLoader#loadFactoryNames(Class,ClassLoader) 方法读取所有 META-INF/spring.factories 资源中 @EnableAutoConfiguration所关联的自动装配 Class 集合。
2. 读取当前配置类所标注的 @EnableAutoConfiguration 属性 exclude 和 excludeName， 并与 spring.autoconfigure.exclude 配置属性合并为 自动装配Class 排除集合。
3. 检查自动装配 Class 排除集合是否合法。
4. 排除候选自动装配 Class 集合中的排除名单。
5. 再次过滤候选自动装配 Class 集合中 Class 不存在的成员。



当自动装配Class 读取完毕后，fireAutoConfigurationImportEvents(List, Set) 方法被执行。



#### @EnableAutoConfiguration自动装配事件

fireAutoConfigurationImportEvents(List, Set) 方法的实现

 ```java
public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware,
		ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered {

	private void fireAutoConfigurationImportEvents(List<String> configurations, Set<String> exclusions) {
		List<AutoConfigurationImportListener> listeners = getAutoConfigurationImportListeners();
		if (!listeners.isEmpty()) {
			AutoConfigurationImportEvent event = 
                new AutoConfigurationImportEvent(this, configurations, exclusions);
			for (AutoConfigurationImportListener listener : listeners) {
				invokeAwareMethods(listener);
				listener.onAutoConfigurationImportEvent(event);
			}
		}
	}
            
	protected List<AutoConfigurationImportListener> getAutoConfigurationImportListeners() {
		return SpringFactoriesLoader.loadFactories(
            AutoConfigurationImportListener.class, this.beanClassLoader);
	}

}
 ```

