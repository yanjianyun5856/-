### 分治法 

计算机求解问题所需的计算时间，与其涉及的数据规模强相关。简而言之，问题所涉及的数据规模越小，它所需的计算时间也越少；反之亦然。

分治法的核心思想就是分而治之。具体来说，它先将一个难以直接解决的大问题，分割成一些可以直接解决的小问题。如果分割后的问题仍然无法直接解决，那么就继续递归地分割，直到每个小问题都可解。

通常而言，这些子问题具备互相独立、形式相同的特点。这样，我们就可以采用同一种解法，递归地去解决这些子问题。最后，再将每个子问题的解合并，就得到了原问题的解。

#### 分治法的价值

例如下面这个问题，在 1000 个有序数字构成的数组 a 中，判断某个数字 c 是否出现过。

​	第一种方法，全局遍历。 复杂度 O(n)。采用 for 循环，对 1000 个数字全部判断一遍。

​	第二种方法，**采用二分查找。 复杂度 O(logn)**。递归地判断 c 与 a 的中位数的大小关系，并不断缩小范围。

这两种方法，对时间的消耗几乎一样。那分治法的价值又是什么呢？

其实，在小数据规模上，分治法没有什么特殊价值。无非就是让代码显得更牛一些。只有在大数据集上，分治法的价值才能显现出来。

#### 分治法的使用方法

当你需要采用分治法时，一般原问题都需要具备以下几个特征：

1. **难度在降低**，即原问题的解决难度，随着数据的规模的缩小而降低。这个特征绝大多数问题都是满足的。
2. **问题可分**，原问题可以分解为若干个规模较小的同类型问题。这是应用分治法的前提。
3. **解可合并**，利用所有子问题的解，可合并出原问题的解。这个特征很关键，能否利用分治法完全取决于这个特征。
4. **相互独立**，各个子问题之间相互独立，某个子问题的求解不会影响到另一个子问题。如果子问题之间不独立，则分治法需要重复地解决公共的子问题，造成效率低下的结果。

根据前面我们对分治法的分析，你一定能迅速联想到递归。分治法需要递归地分解问题，再去解决问题。因此，**分治法在每轮递归上，都包含了分解问题、解决问题和合并结果这 3 个步骤**。



##### 二分查找

 思路步骤如下：

1. 选择一个标志 i 将集合 L 分为二个子集合，一般可以使用中位数；
2. 判断标志 L(i) 是否能与要查找的值 des 相等，相等则直接返回结果；
3. 如果不相等，需要判断 L(i) 与 des 的大小；
4. 基于判断的结果决定下步是向左查找还是向右查找。如果向某个方向查找的空间为 0，则返回结果未查到；
5. 回到步骤 1。

```java
public static void main(String[] args) {
	// 需要查找的数字
	int targetNumb = 8;
	// 目标有序数组
	int[] arr = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
	int middle = 0;
	int low = 0;
	int high = arr.length - 1;
    int isfind = 0;

	while (low <= high) {
		middle = (high + low) / 2;
		if (arr[middle] == targetNumb) {
			System.out.println(targetNumb + " 在数组中,下标值为: " + middle);
            isfind = 1;
			break;
		} else if (arr[middle] > targetNumb) {
			// 说明该数在low~middle之间
			high = middle - 1;
		} else {
			// 说明该数在middle~high之间
			low = middle + 1;
		}
    }
    if (isfind == 0) {
			System.out.println("数组不含 " + targetNumb);
	}
}
```

##### 二分查找的规律

二分查找的时间复杂度是 O(logn)，这也是分治法普遍具备的特性。当你面对某个代码题，而且约束了时间复杂度是 O(logn) 或者是 O(nlogn) 时，可以想一下分治法是否可行。

二分查找的循环次数并不确定。一般是达到某个条件就跳出循环。因此，编码的时候，多数会采用 while 循环加 break 跳出的代码结构。

二分查找处理的原问题必须是有序的。因此，当你在一个有序数据环境中处理问题时，可以考虑分治法。相反，如果原问题中的数据并不是有序的，则使用分治法的可能性就会很低了。









