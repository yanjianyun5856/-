### 复杂度

复杂度是一个关于输入数据量 n 的函数

假设你的代码复杂度是 f(n)，那么就用个大写字母 O 和括号，把 f(n) 括起来就可以了，即 O(f(n))。

O(n) 表示的是，复杂度与计算实例的个数 n 线性相关；

O(logn) 表示的是，复杂度与计算实例的个数 n 对数相关。



##### 复杂度包含

1. 时间复杂度	
2. 空间复杂度



##### 复杂度的计算原则

1. 复杂度与具体的常系数无关，例如 O(n) 和 O(2n) 表示的是同样的复杂度。我们详细分析下，O(2n) 等于 O(n+n)，也等于 O(n) + O(n)。也就是说，一段 O(n) 复杂度的代码只是先后执行两遍 O(n)，其复杂度是一致的。
2. 多项式级的复杂度相加的时候，选择高者作为结果，例如 O(n²)+O(n) 和 O(n²) 表示的是同样的复杂度。具体分析一下就是，O(n²)+O(n) = O(n²+n)。随着 n 越来越大，二阶多项式的变化率是要比一阶多项式更大的。因此，只需要通过更大变化率的二阶多项式来表征复杂度就可以了。

O(1) 也是表示一个特殊复杂度，含义为某个任务通过有限可数的资源即可完成。此处有限可数的具体意义是，与输入数据量 n 无关。



##### 一些经验性的结论：

1. 一个顺序结构的代码，时间复杂度是 O(1)。
2. 二分查找，或者更通用地说是采用分而治之的二分策略，时间复杂度都是 O(logn)。。
3. 一个简单的 for 循环，时间复杂度是 O(n)。
4. 两个顺序执行的 for 循环，时间复杂度是 O(n)+O(n)=O(2n)，其实也是 O(n)。
5. 两个嵌套的 for 循环，时间复杂度是 O(n²)。





#### 降低复杂度的方法

1. 暴力解法。在没有任何时间、空间约束下，完成代码任务的开发。
2. 无效操作处理。将代码中的无效计算、无效存储剔除，降低时间或空间复杂度。
3. 时空转换。设计合理数据结构，完成时间复杂度向空间复杂度的转移。



##### 查找出一个数组中，出现次数最多的那个元素的数值。

例如，输入数组 a = [1,2,3,4,5,5,6 ] 中，查找出现次数最多的数值。

###### 方法一

工程师小明的解决方法是，采用两层的 for 循环完成计算。第一层循环，对数组每个元素遍历。第二层循环，则是对第一层遍历的数字，去遍历计算其出现的次数。这样，全局再同时缓存一个出现次数最多的元素及其次数就可以了。具体代码如下：

```java
public void s2_3() {
	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
	int val_max = -1;
	int time_max = 0;
	int time_tmp = 0;
	for (int i = 0; i < a.length; i++) {
		time_tmp = 0;
		for (int j = 0; j < a.length; j++) {
			if (a[i] == a[j]) {
				time_tmp += 1;
			}
			if (time_tmp > time_max) {
				time_max = time_tmp;
				val_max = a[i];
			}
		}
	}
	System.out.println(val_max);
}

```

在这段代码中，小明采用了两层的 for 循环，很显然时间复杂度就是 O(n²)。



###### 方法二

定义一个 k-v 结构的字典，用来存放元素-出现次数的 k-v 关系。那么首先通过一次循环，将数组转变为元素-出现次数的一个字典。接下来，再去遍历一遍这个字典，找到出现次数最多的那个元素，就能找到最后的结果了。

```java
public void s2_4() {
	int a[] = { 1, 2, 3, 4, 5, 5, 6 };
	Map<Integer, Integer> d = new HashMap<>();
	for (int i = 0; i < a.length; i++) {
		if (d.containsKey(a[i])) {
			d.put(a[i], d.get(a[i]) + 1);
		} else {
			d.put(a[i], 1);
		}
	}
	int val_max = -1;
	int time_max = 0;
	int count = 0;
	for (Integer key : d.keySet()) {
		if (d.get(key) > time_max) {
			time_max = d.get(key);
			val_max = count;
		}
		count++;
	}
	System.out.println(d);
}

```

我们来计算下这种方法的时空复杂度。代码结构上，有两个 for 循环。不过，这两个循环不是嵌套关系，而是顺序执行关系。其中，第一个循环实现了数组转字典的过程，也就是 O(n) 的复杂度。第二个循环再次遍历字典找到出现次数最多的那个元素，也是一个 O(n) 的时间复杂度。

因此，总体的时间复杂度为 O(n) + O(n)，就是 O(2n)，根据复杂度与具体的常系数无关的原则，也就是O(n) 的复杂度。空间方面，由于定义了 k-v 字典，其字典元素的个数取决于输入数组元素的个数。因此，空间复杂度增加为 O(n)。



这里的数据操作包括以下 3 个。

1. 查找： 看能否在数据结构中查找到这个元素，也就是判断元素是否出现过。
2. 新增： 针对没有出现过的情况，新增这个元素。
3. 改动： 针对出现过的情况，需要对这个元素出现的次数加 1。



因此，这段代码需要高频使用查找的功能。此时，第一步的查找动作嵌套在 for 循环中，如果你的代码不能在 O(1) 的时间复杂度内完成，则代码整体的时间复杂度并没有下降。而能在 O(1) 的时间复杂度内完成查找动作的数据结构，只有字典类型。这样，外层 for 循环是 O(n) 的时间复杂度，内部嵌套的查找操作是 O(1) 的时间复杂度。整体计算下来，就仍然是 O(n) 的时间复杂度。字典的查找是通过键值对的匹配完成的，它可以在 O(1) 时间复杂度内，实现对数值条件查找。关于字典的内容，我们在后续的课程中会详细解答。

现在，我们换个解决方案。假设采用两个数组，分别按照对应顺序记录元素及其对应的出现次数。数组对于元素的查找只能逐一访问，时间复杂度是 O(n)。也就是说，在 O(n) 复杂度的 for 循环中，又嵌套了 O(n) 复杂度的查找动作，所以时间复杂度是 O(n²)。因此，这里的数据结构，只能采用字典类型。



#####而设计合理的数据结构，可以采用这样的思考顺序：

1. 首先我们分析这段代码到底对数据先后进行了哪些操作。
2. 然后再根据分析出来的数据操作，找到合理的数据结构。



其实，代码对数据处理的操作类型非常少。代码对数据的处理就是代码对输入数据进行计算，得到结果并输出的过程。数据处理的操作就是找到需要处理的数据，计算结果，再把结果保存下来。这个过程总结为以下操作：

1. 找到要处理的数据。这就是按照某些条件进行查找。
2. 把结果存到一个新的内存空间中。这就是在现有数据上进行新增。
3. 把结果存到一个已使用的内存空间中。这需要先删除内存空间中的已有数据，再新增新的数据。



经过对代码的拆解，你会发现即便是很复杂的代码，它对数据的处理也只有这 3 个基本操作，增、删、查。只要你围绕这 3 个数据处理的操作进行分析，就能得出解决问题的最优方案。常用的分析方法可以参考下面的 3 个步骤：

1. 首先，这段代码对数据进行了哪些操作？
2. 其次，这些操作中，哪个操作最影响效率，对时间复杂度的损耗最大？
3. 最后，哪种数据结构最能帮助你提高数据操作的使用效率？



数据处理的基本操作只有 3 个，分别是增、删、查。其中，增和删又可以细分为在数据结构中间的增和删，以及在数据结构最后的增和删。区别就在于原数据的位置是否发生改变。查找又可以细分为**按照位置条件的查找**和**按照数据数值特征的查找**。几乎所有的数据处理，都是这些基本操作的组合和叠加。

