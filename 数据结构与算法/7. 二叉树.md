### 二叉树

在二叉树中，每个结点最多有两个分支，即每个结点最多有两个子结点，分别称作左子结点和右子结点。

结点的层次从根结点算起，根为第一层，根的“孩子”为第二层，根的“孩子”的“孩子”为第三层，依此类推。

树中结点的最大层次数，就是这棵树的树深（称为深度，也称为高度）。



在二叉树中，有下面两个特殊的类型 ：

1. 满二叉树，定义为除了叶子结点外，所有结点都有 2 个子结点。
2. 完全二叉树，定义为除了最后一层以外，其他层的结点个数都达到最大，并且最后一层的叶子结点都靠左排列。



存储二叉树有两种办法，一种是基于指针的链式存储法，另一种是基于数组的顺序存储法。

1. 链式存储法，也就是像链表一样，每个结点有三个字段，一个存储数据，另外两个分别存放指向左右子结点的指针
2. 顺序存储法，就是按照规律把结点存放在数组里，如下图所示，为了方便计算，我们会约定把根结点放在下标为 1 的位置。随后，B 结点存放在下标为 2 的位置，C 结点存放在下标为 3 的位置，依次类推。



#### 树的基本操作

遍历一棵树，有非常经典的三种方法，分别是前序遍历、中序遍历、后序遍历。这里的序指的是父结点的遍历顺序，前序就是先遍历父结点，中序就是中间遍历父结点，后序就是最后遍历父结点。不管哪种遍历，都是通过递归调用完成的。

1. 前序遍历，对树中的任意结点来说，先打印这个结点，然后前序遍历它的左子树，最后前序遍历它的右子树。
2. 中序遍历，对树中的任意结点来说，先中序遍历它的左子树，然后打印这个结点，最后中序遍历它的右子树。
3. 后序遍历，对树中的任意结点来说，先后序遍历它的左子树，然后后序遍历它的右子树，最后打印它本身。

```java
	// 先序遍历
	public static void preOrderTraverse(Node node) {
		if (node == null)
			return;
		System.out.print(node.data + " ");
		preOrderTraverse(node.left);
		preOrderTraverse(node.right);
	}
	// 中序遍历
	public static void inOrderTraverse(Node node) {
		if (node == null)
			return;
		inOrderTraverse(node.left);
		System.out.print(node.data + " ");
		inOrderTraverse(node.right);
	}
	// 后序遍历
	public static void postOrderTraverse(Node node) {
		if (node == null)
			return;
		postOrderTraverse(node.left);
		postOrderTraverse(node.right);
		System.out.print(node.data + " ");
	}
```



#### 二叉查找树

二叉查找树（也称作二叉搜索树）具备以下几个的特性：

1. 在二叉查找树中的任意一个结点，其左子树中的每个结点的值，都要小于这个结点的值。
2. 在二叉查找树中的任意一个结点，其右子树中每个结点的值，都要大于这个结点的值。
3. 在二叉查找树中，会尽可能规避两个结点数值相等的情况。
4. 对二叉查找树进行中序遍历，就可以输出一个从小到大的有序数据队列。

##### 二叉查找树的查找操作

在利用二叉查找树执行查找操作时，我们可以进行以下判断：

1. 首先判断根结点是否等于要查找的数据，如果是就返回。
2. 如果根结点大于要查找的数据，就在左子树中递归执行查找动作，直到叶子结点。
3. 如果根结点小于要查找的数据，就在右子树中递归执行查找动作，直到叶子结点。

这样的“二分查找”所消耗的时间复杂度就可以降低为 O(logn)。关于二分查找，我们会在后续的分治法一讲中详细讲述。

##### 二叉查找树的插入操作

在二叉查找树执行插入操作也很简单。从根结点开始，如果要插入的数据比根结点的数据大，且根结点的右子结点不为空，则在根结点的右子树中继续尝试执行插入操作。直到找到为空的子结点执行插入动作。

二叉查找树插入数据的时间复杂度是 O(logn)。但这并不意味着它比普通二叉树要复杂。原因在于这里的时间复杂度更多是消耗在了遍历数据去找到查找位置上，真正执行插入动作的时间复杂度仍然是 O(1)。

##### 二叉查找树的删除操作

二叉查找树的删除操作会比较复杂，这是因为删除完某个结点后的树，仍然要满足二叉查找树的性质。我们分为下面三种情况讨论。

1.  如果要删除的结点是某个叶子结点，则直接删除，将其父结点指针指向 null 即可。
2. 情况二，如果要删除的结点只有一个子结点，只需要将其父结点指向的子结点的指针换成其子结点的指针即可。
3. 如果要删除的结点有两个子结点，则有两种可行的操作方式。第一种，找到这个结点的左子树中最大的结点，替换要删除的结点。第二种，找到这个结点的右子树中最小的结点，替换要删除的结点。

#### 树的案例

输入一个字符串，判断它在已有的字符串集合中是否出现过?

（假设集合中没有某个字符串与另一个字符串拥有共同前缀且完全包含的特殊情况，例如 deep 和 dee。）如，已有字符串集合包含 6 个字符串分别为，cat, car, city, dog,door, deep。输入 cat，输出 true；输入 home，输出 false。

我们假设采用最暴力的办法，估算一下时间复杂度。假设字符串集合包含了 n 个字符串，其中的字符串平均长度为 m。那么新来的一个字符串，需要与每个字符串的每个字符进行匹配。则时间复杂度为 O(nm)。

但在 nm 的复杂度中，显然存在很多的无效匹配。例如，输入 home 时，6 个字符串都没有 h 开头的，则不需要进行后续的匹配。因此，如果可以通过对字符前缀进行处理，就可以最大限度地减少无谓的字符串比较，从而提高查询效率。这就是“用空间换时间”的思想，再利用共同前缀来提高查询效率。

其实，这个问题利用树结构也可以完成。我们对字符串建立一个的树结构， 它将字符串集合的前缀进行合并，每个根结点到叶子结点的链条就是一个字符串。

这个树结构也称作 Trie 树，或字典树。它具有三个特点：

​	第一，根结点不包含字符；

​	第二，除根结点外每一个结点都只包含一个字符；

​	第三，从根结点到某一叶子结点，路径上经过的字符连接起来，即为集合中的某个字符串。

这个问题的解法可以拆解为以下两个步骤：

​	第一步，根据候选字符串集合，建立字典树。这需要使用数据插入的动作。

​	第二步，对于一个输入字符串，判断它能否在这个树结构中走到叶子结点。如果能，则出现过。



#### 总结

 要想利用二叉树实现增删查操作，你需要熟练掌握二叉树的三种遍历方式。遍历的时间复杂度是 O(n)。有了遍历方式之后，你可以完成在指定位置的数据增删操作。增删操作的时间复杂度都是 O(1)。

对于查找操作，如果是普通二叉树，则查找的时间复杂度和遍历一样，都是 O(n)。如果是二叉查找树，则可以在 O(logn) 的时间复杂度内完成查找动作。树结构在存在“一对多”的数据关系中，可被高频使用，这也是它区别于链表系列数据结构的关键点。