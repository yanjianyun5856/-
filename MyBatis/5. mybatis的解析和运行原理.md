###  Mybatis的解析和运行原理

#### JDK动态代理

JDK动态代理由JDK的 java.lang.reflect.* 包提供支持

#####接口

```java
public interface HelloService{
    public void sayHello(String name);
}
```

#####  实现类

```java
public class HelloServiceImpl implements HelloService{
    public void sayHello(String name){
    	System.out.println(name);
    }
}
```

##### 代理类

```java
public class HelloServiceProxy implements InvocationHadler {
    private Object target;//真实服务对象
    
    //绑定委托对象，并返回一个代理对象
    public Object bind(Object target){
        this.target = target;
        //取得代理对象
        return Proxy.newProxyInstance(
            	 target.getClass().getClassLoader(),//类加载器
                 target.getClass.getInterfaces(),//代理对象挂在哪个接口下
                 this //使用 代理方法作为 对象的代理执行者
        	   );
    }
    
    /**
     *	通过代理对象调用方法首先进入这个方法
     *		proxy  代理对象
     *		method	被调用方法
     *		args	方法参数
     */
    public Object invoke(Object proxy,Method method,Object[] args) throws Throwable{
        Object result = null;
        //执行方法
        result = method.invode(target，args)； //反射调用方法  对象，参数
        return result;
    }
}
```

#####  客户端

```java
public class HelloServiceProxyDemo{
    public class void main(String[] args){
        HelloServiceProxy helloHandler = new HelloServiceProxy();
        //绑定委托对象，并返回一个代理对象
        HelloService proxy = (HelloService)helloHandler.bind(new HelloServiceImpl());
        proxy.sayHello("hello,world");
    }
}
```



####  CGLIB动态代理

```java
public class HelloServiceCglib implements MethodInterceptor {
    private Object target;
    
    //创建代理对象
    public Object getInstance(Object target){
        this.target = target;
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperClass(this.target.getClass());
        //回调方法
        enhancer.setCallback(this);
        //创建代理对象
        return enhancer.create();
    }
    
    //回调方法
    @Override
    public Object intercept(Object obj,Method method,
                     Object[] args, MethodProxy proxy)  throws Throwable{
        
        Object returnObject = invokeSuper(obj, args);
        
        return returnObject;
    }
}
```



#### SqlSessionFactory 构建过程

1. 通过`org.apache.ibatis.builder.xml.XMLConfigBuilder` 解析配置的 XML文件，读出配置参数，并将读取的数据存入`org.apache.ibatis.session.Configuration`类中。
2. 使用Configuration对象创建SqlSessionFactory。MyBatis中的SqlSessionFactory是一个接口，一般使用它的实现类`org.apache.ibatis.session.defaults.DefaultSqlSessionFactory` 。

#####   Configuration构建

Configuration的作用

1. 读入配置文件，包括基础配置的xml文件和映射器的xml文件
2. 初始化基础配置
3. 提供单例，为后续创建SessionFactory服务提供配置参数
4. 执行一些重要的对象方法，初始化配置信息

#####  映射器的内部组成

一般映射器由3个部分组成

1. MappedStatement，它保存映射器的一个节点，包括许多我们配置的SQL、SQL的id、缓存信息、resultMap、parameterType、resultType等重要配置内容
2. SqlSource，它是提供BoundSql对象的地方，它是MappedStatement的一个属性
3. BoundSql，它是建立Sql和参数的地方。他有三个常用的属性：SQL、parameterObject、parameterMappings

###### parameterObject 为参数本身

​	传递简单对象时 mybatis 会把参数变为 对应的包装类型
​	传递pojo 或 Map ，那么 parameterObject 就是你传入的 POJO 或 Map 不变
​	传递多个参数，没有使用 @Param 注解  ，mybatis 会把 parameterObject变为 Map<String,Object>,  map的key 为参数的顺序。 ` map {"1": p1,"2": p2, ...}`
​	传递多个参数，使用` @Param` 注解  ，mybatis 会把 parameterObject变为 Map<String,Object>, map的key 为` @Param`注解的键值。` @Param("key1") String p1  -> map {"key1": p1, ...}`

###### parameterMappings 		

parameterMappings 是一个list，它的每一个元素都是 ParameterMapping 的对象，这个对象会描述我们的参数。参数包括属性、名称、表达式、javaType、JDBCType、typeHandler 等。 PreparedStatement 能够通过它找到 parameterObject 对象的属性并设置参数

 ######  SQL

SQL 是我们书写在 映射器 里面的一条SQL	